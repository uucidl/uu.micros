* Discussion

This was prompted by alex' tweet about doing a round robin demo.

https://twitter.com/mmalex/status/403818676224544768
#+begin_example
<mmalex> Been wondering about doing an async 'chain' collab demo for years: rules: c++/GL only, 1 week work then pass it on... Repeat until deadline
<javiercampos> @mmalex Isn't that the exact opposite to async? :-)
<gpakosz> @mmalex on top of existing ground work demo system or from scratch?
<mmalex> @javiercampos heh :) I guess you're right! What's the right word...
<LiaSae> @mmalex The technical term for this in the cross-stitch word is round-robin :) Could apply as well!
<LiaSae> @mmalex Make that "world", d'oh.
<mmalex> @LiaSae we could upload the result to ravelry! :)
<â€LiaSae> @mmalex I'd love to see more fabric-like style in games (Epic Yarn, Little Big Planet, and.... there ain't much else) / demos, so why not :)
<kamidphish> @mmalex Is that like the old C64 demos?
<nvining> @mmalex I'm in.
<_psonice> @LiaSae there was zen bondage / zen bound, if that counts. A game full of soft objects/scenery instead of hard would be cool tho! @mmalex
<Flawe> @mmalex very cool idea!
<uucidl> @mmalex I always wanted to do this yet it's always a problem with coders being anal about their frameworks and build systems etc..
<mmalex> @uucidl lowest common denominator ftw! build batch file/shellscript, minimum external deps (GL/playmp3()/gnurocket/stb_*), GO! ?
<uucidl> @mmalex and no data file, everything generated or in-source ;)
<mmalex>@uucidl yeah! and, drop playmp3() and replace with fill_48khz_stereo_buf_plz() callback -> synth.
<ElMarcel> @Flawe @mmalex Awesome!
<DeanoC>@mmalex could be fun. Different section per author or keep modifying the same bit, see where it evolves?
<DeanoC>@mmalex One section, where each week its evolved by the next coder or each do a seperate section link to the previous? Either way sounds fun
<keyboardjockey> @mmalex interesting. Should have each person branch off and have the next dev perform the merge, to become familiar.
#+end_example

* Specs

- shell script build (clean + rebuild + test + run)
- host system with GL and audio
- source only libraries accepted
- C++ only supported

Personal comment:
- I don't like people arguing about code style, so having an automatic
  formatter could help. (see artistic style)

* Requirements

- git (+ on windows the msys environment that comes with it)
find it at http://git-scm.com/
- a C++11 compiler (gcc, clang, visual studio)

All the rest shipped within the tree
* API
:PROPERTIES:
:mkdirp: yes
:END:

Using our experience to define the most minimal and useful hooks to
code a demo we come with the following:

#+begin_src cpp :mkdir yes :tangle include/api.h
#include <cstdint>

//! initialize runtime (and start the demo)
extern void runtime_init();

//! current time in microseconds
extern uint64_t now_micros();

//! entry point: called for each new video frame (called in strict order)
//! \param time_micros scheduling time for the frame
extern void render_next_gl(uint64_t time_micros);

//! entry point: called for each new audio frame (called in strict order)
//! \param time_micros scheduling time for the first sample of the frame
//! \param sample_count count of stereo audio sample to fill
//! \param left buffer of audio samples for the left channel
//! \param right buffer of audio samples for the right channel
extern void render_next_2chn_48khz_audio(uint64_t time_micros,
		int const sample_count, double* left[/*sample_count*/],
		double right[/*sample_count*/]);
#+end_src

* Writing a new runtime

Put your os specific code under a subdirectory of runtime like so:

runtime/Darwin/display.cpp

Then hook it up inside the platform specific compile function.

It should open a window with an OpenGL context. It should quit the
demo when pressing ESC or Right clicking.

It should continuously redisplay frames and delegate their rendering
to the API entry points.

* Ideas

- Use Regal as a compatibility layer for all the various opengl
  implementations

- in lib you will find all stb libs for image loading, truetype/vorbis
  support at least. All the rest can come from demo or c++11 or any
  other source available lib that can be put in the tree.

- we enforce a single C++ standard (C++11)

- we enforce a single code style (the build script format files
  automatically)

Linux code style with 8 space indents. Can evolve / be edited in the .astylerc
file if you prefer something else for your own coding segment.

Don't put editor specific stuff in source files

- a base runtime will be provided for mac/linux/pc (based on the most
  basic lib available)

- build script always rebuild the entire demo (it should not grow big
  enough for it to matter)

- the build script always create builds in a separate dirs according to hostname

- the build script can be edited to define compilation flags per
  machine or platform (for custom/weird environments)
